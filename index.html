<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><title
    >ICFP 2009 Programming Contest Diary</title
    ><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"
     /><meta name="generator" content="pandoc"
     /><meta name="author" content="Justin Bailey"
     /><meta name="date" content="June 25, 2009"
     /><link rel="stylesheet" href="style.css" type="text/css" media="all" />
</head
  ><body
  ><h1 class="title"
    >ICFP 2009 Programming Contest Diary</h1
    ><div id="wrapper">
<div id="masthead" class="fix" style="width: 100%">
<h1 class="sans"><a href="http://blog.codeslower.com" class="title">codeslower.com</a> <em>Savor Your Code.</em></h1>
</div>
<div id="mid" class="fix">
<div id="mainCol" class="fix">
<div id="article" class="post">

<div style="text-align: center"><h2 id="the-icfp-2009-programming-contest--a-diary"
    >The ICFP 2009 Programming Contest &#8212; A diary.</h2
    ><strong
    >Justin Bailey</strong
    > &lt;<tt>jgbailey@codeslower.com</tt>&gt;</div>

<div id="blogbody" class="entry">
<h3 id="june-25-2009----900-am"
    >June 25, 2009 -- 9:00 AM</h3
    ><p
    >This site will serve as a diary and reference for my work on the upcoming <a href="http://www.icfpcontest.org"
      >ICFP 2009 programming contest</a
      >. All code committed will be available on <a href="http://github.com/m4dc4p/func-n-stein/tree/master"
      >GitHub</a
      > and can be cloned from <tt>git://github.com/m4dc4p/func-n-stein.git</tt>.</p
    ><h3 id="june-25-2009----1143-am"
    >June 25, 2009 -- 11:43 AM</h3
    ><p
    >All times PDT, by the way.</p
    ><p
    >Downloaded the spec, read through it, seems a lot like last years problem. I have to implement a virtual machine and then solve a bunch of orbit problems? Sounds doubly tough. For starters I think I will implement something to write the <em
      >submission</em
      > format, and submit an empty solution. We'll see what happens.</p
    ><h3 id="june-25-2009----203-pm"
    >June 25, 2009 -- 2:03 PM</h3
    ><p
    >Got code to write a solution and have submitted an empty solution. Not sure if double representation will be written correctly - does Haskell write it in &quot;IEEE 764&quot; notation automatically? Had to do some pointer conversions to write doubles as binary data:</p
    ><pre
    ><code
      >          v &lt;- allocaBytes 8 $ \p -&gt; do 
                   poke p val 
                   mapM (\i -&gt; peekElemOff (castPtr p) i) [0, 1]
</code
      ></pre
    ><p
    >''val'' is our double value. I write to 8 byte memory location, then read out as two 32-bit values:</p
    ><pre
    ><code
      >          -- write to file
          hPutWord (int2Word addr)
          hPutWord (v !! 0)
          hPutWord (v !! 1)
</code
      ></pre
    ><p
    >''hPutWord'' fixes the type, as it takes a Word32 and writes it to a file:</p
    ><pre
    ><code
      > hPutWord :: Word32 -&gt; IO ()
 hPutWord w = with w $ \p -&gt; do
      hPutBuf h p (sizeOf w)
</code
      ></pre
    ><p
    >I do se a bug above, where I am not writing the value in little-endian order. Better fix that!</p
    ><h3 id="june-25-2009----252-pm"
    >June 25, 2009 -- 2:52 PM</h3
    ><p
    >Fairly confident output file format is being written correctly. At least the competition server doesn't complain When I submit solutions that write to the correct config port. Also cabalized early so it won't be too painful later -- I expect dependencies to grow.</p
    ><p
    >Now I'll write some code to read the executable file format.</p
    ><h3 id="june-25-2009----337-pm"
    >June 25, 2009 -- 3:37 PM</h3
    ><p
    >Got some code that seems to read the executable file format (''ReadObf.hs''). Lots of grungy work with pointers, bits and bytes here. Reading words and doubles is a lot like writing them:</p
    ><pre
    ><code
      >        getWord p i = do
            v &lt;- peekElemOff (castPtr p) i
            return $ (v :: Word32)
        getDouble p i = do
            v &lt;- peekElemOff (castPtr p) i
            return $ (v :: Double)
</code
      ></pre
    ><p
    >where ''p'' points to the buffer containing the file in memory and ''i'' is an absolute offset to start reading from. For some reason the file format alternates between (instr, val) and (val, instr). I created two nearly identical functions to read each:</p
    ><pre
    ><code
      >        toInstrE i = do
            -- With even addresses, instruction comes first.
            instr &lt;- getWord p i 
            val &lt;- getDouble p (i + 1)
            return $ Instr instr val
        toInstrO i = do
            -- With odd addresses, value comes first.
            val &lt;- getDouble p i
            instr &lt;- getWord p (i + 2)
            return $ Instr instr val
</code
      ></pre
    ><p
    >''Instr Word32 Double'' will represent a raw instruction, before it is translated to an op code/value pair for the machine. Then I need to iterate over the array to convert each 96-bit value into an ''Instr'' value. ''foldM'' looked like the right fit:</p
    ><pre
    ><code
      >    instrs &lt;- foldM (\is (f, i) -&gt; f i is) [] (zip (cycle [applyE, applyO]) [0,3..size])
</code
      ></pre
    ><p
    >Ouch! ''applyE'' and ''applyO'' let me alternate the function I am using to convert values:</p
    ><pre
    ><code
      >        applyE i instrs = do
            is &lt;- toInstrE i
            return (is : instrs)
        applyO i instrs = do
            is &lt;- toInstrO i
            return (is : instrs)
</code
      ></pre
    ><p
    >''[0,3..size]'' give me the indices to read process every 3 words in the buffer. ''cycle [applyE, applyO]'' gives me a list of alternating functions to apply. I zip those together and fold. My instructions pop out the other end!</p
    ><h3 id="june-25-2009----1051-pm"
    >June 25, 2009 -- 10:51 PM</h3
    ><p
    >Everything looked good until I tried to convert the bytes read from the executable format to opcodes. &quot;Unrecognized D-type op: 9&quot; -- WTF? All I can say is - bastards! The instructions are stored in reverse binary. For example, the spec says a D-type op code occupies bits &quot;31 - 28&quot;, with value from 0x1 - 0x6. I assumed the bits were in 28 - 31, in <em
      >that</em
      > order. No! I am pretty sure 0x1 is represented as &quot;1000&quot; (from 31 - 28), not &quot;0001&quot;! Well, hopefully this page on <a href="http://graphics.stanford.edu/~seander/bithacks.html#BitReverseObvious"
      >bit-twiddling tricks</a
      > has an algorith for reversing a word. I should be able to hide that from the rest of the program and convert to opcodes.</p
    ><h3 id="june-26-2009----640-am"
    >June 26, 2009 -- 6:40 AM</h3
    ><p
    >I'm still not sure if the instruction word needs to be reversed, because I wasted a bunch of time trying to figure out why I was reading illegal instructions in the .obf file. I went to bed last night stuck -- it seemed I was reading the file incorrectly, or at least that's all I could guess. I figured it had something to do with ''little-endianess,'' which I felt unsure of. I was all ready to go back to first principles and experiment with reading and writing obf files. Fortunately I decided to look over the problem description again while I was eating breakfast. Lo and behold, I had the executable format wrong -- I coded it so that the instruction came first on <strong
      >even</strong
      > frames. That's wrong -- it's <strong
      >odd</strong
      > frames! Making that small switch allowed me to read the obf file correctly.</p
    ><p
    >Now to determine if the instructions are stored reversed or not.</p
    ><h3 id="june-26-2009----653-am"
    >June 26, 2009 -- 6:53 AM</h3
    ><p
    >Bingo! No reversal needed. Hallelujah. A quick test showed that parsing the obf file failed with the reversal added. Ergo, it must be wrong. Now let's implement our machine.</p
    ><h3 id="june-26-2009----245-pm"
    >June 26, 2009 -- 2:45 PM</h3
    ><p
    >The machine seems to be working and is fairly performant, though not amazing. 10000 iterations on bin1 go pretty fast. 100,000 or 1,000,000 get progressively worse. Hopefully it won't be too bad. Simulating a machine with mutable memory is always interesting in Haskell. The magic of ''runSTUArray'' is saving me here. Each iteration of the machine is run inside the ST monad, which allows me to modify a mutable array (from Machine.hs):</p
    ><pre
    ><code
      >step :: Machine -&gt; STUArray s Int Val -&gt; (OpCode, Addr) -&gt; ST s (STUArray s Int Val)
step m mem (op, addr) = ...
</code
      ></pre
    ><p
    >''mem'' is my mutable array. While the machine executes its program once, I can update the array as much as I like. You can see that in action in the ''exec'' function:</p
    ><pre
    ><code
      >exec :: Machine -&gt; Input -&gt; Machine
exec m@(Machine { instrs = instrs }) inps = 
     let m' = m { inputs = readInputs inps }
         newMem = runSTUArray $ do
                mem' &lt;- thaw (dataMem m)
                foldM (step m') mem' (zip instrs [0..])
</code
      ></pre
    ><p
    >''foldM'' takes care of executing all instructions, while step updates the mutable array as needed. The final array is returned by runSTUArray as an <strong
      >immutable</strong
      > array, meaning its like any other Haskell value.</p
    ><p
    >This is a fast way to deal with mutable values but there are some downsides. Since I want to keep a trace of the output around, I can't reuse the same array on subsequent iterations (at least, not safely). That is why you see ''thaw'' in there, instead of ''unsafeThaw''.</p
    ><p
    >The second is that runSTUArray can <strong
      >only</strong
      > return a single array. The machine has several mutable values: memory, output ports, and the status register. I have no idea if output ports can be written to more than once, but better safe than sorry. So the mutable array above actually holds all those values, and I split it up at the end of each execution (where ''newMem'' is the final state of memory after the iteration):</p
    ><pre
    ><code
      >    outputs = runSTUArray $ do
        -- output ports after memory in array.
        newListArray (0, outputSize) (map (newMem !) [memSize .. memSize + outputSize - 1])
    statusA = runSTUArray $ do
        -- status bit at end of memory
        newListArray (0, 1) [newMem ! (memSize + outputSize)] 
</code
      ></pre
    ><p
    >Since I still have no idea how to do the math for these problems, I'm going to try and use chalkboard (from Hackage) to write a visualizer so I can see what these orbits look like ...</p
    ></div>
</div>
</div>
</div>
</div>

</body
  ></html
>


% ICFP 2009 Programming Contest Diary
% Justin Bailey
% June 25, 2009
<div id="wrapper">
<div id="masthead" class="fix" style="width: 100%">
<h1 class="sans"><a href="http://blog.codeslower.com" class="title">codeslower.com</a> <em>Savor Your Code.</em></h1>
</div>
<div id="mid" class="fix">
<div id="mainCol" class="fix">
<div id="article" class="post">

<div style="text-align: center">
## The ICFP 2009 Programming Contest &#8212; A diary.
**Justin Bailey** \<<tt>jgbailey@codeslower.com</tt>\>
</div>

<div id="blogbody" class="entry">

### June 25, 2009 -- 9:00 AM

This site will serve as a diary and reference for my work on the
upcoming [ICFP 2009 programming contest](http://www.icfpcontest.org). All code committed will be
available on
[GitHub](http://github.com/m4dc4p/func-n-stein/tree/master) and can be
cloned from <tt>git://github.com/m4dc4p/func-n-stein.git</tt>.

### June 25, 2009 -- 11:43 AM

All times PDT, by the way. 

Downloaded the spec, read through it, seems a lot like last years problem. I have to implement a 
virtual machine and then solve a bunch of orbit problems? Sounds doubly tough. For starters I think 
I will implement something to write the *submission* format, and submit an empty solution. We'll see
what happens.

### June 25, 2009 -- 2:03 PM

Got code to write a solution and have submitted an empty solution. Not sure if double representation
will be written correctly - does Haskell write it in "IEEE 764" notation automatically? Had to do some
pointer conversions to write doubles as binary data:

              v <- allocaBytes 8 $ \p -> do 
                       poke p val 
                       mapM (\i -> peekElemOff (castPtr p) i) [0, 1]

''val'' is our double value. I write to 8 byte memory location, then read out as two 32-bit values:

              -- write to file
              hPutWord (int2Word addr)
              hPutWord (v !! 0)
              hPutWord (v !! 1)

''hPutWord'' fixes the type, as it takes a Word32 and writes it to a file:

     hPutWord :: Word32 -> IO ()
     hPutWord w = with w $ \p -> do
          hPutBuf h p (sizeOf w)


I do se a bug above, where I am not writing the value in little-endian order. Better fix that!

### June 25, 2009 -- 2:52 PM

Fairly confident output file format is being written correctly. At least the competition server doesn't
complain When I submit solutions that write to the correct config port. Also cabalized early so it won't be
too painful later -- I expect dependencies to grow.

Now I'll write some code to read the executable file format.

### June 25, 2009 -- 3:37 PM

Got some code that seems to read the executable file format (''ReadObf.hs''). Lots of
grungy work with pointers, bits and bytes here. Reading words and doubles
is a lot like writing them:

            getWord p i = do
                v <- peekElemOff (castPtr p) i
                return $ (v :: Word32)
            getDouble p i = do
                v <- peekElemOff (castPtr p) i
                return $ (v :: Double)

where ''p'' points to the buffer containing the file in memory and ''i'' is an
absolute offset to start reading from. For some reason the
file format alternates between (instr, val) and (val, instr). I created two nearly
identical functions to read each:

            toInstrE i = do
                -- With even addresses, instruction comes first.
                instr <- getWord p i 
                val <- getDouble p (i + 1)
                return $ Instr instr val
            toInstrO i = do
                -- With odd addresses, value comes first.
                val <- getDouble p i
                instr <- getWord p (i + 2)
                return $ Instr instr val

''Instr Word32 Double'' will represent a raw instruction, before it is translated
to an op code/value pair for the machine. Then I need to iterate over the array
to convert each 96-bit value into an ''Instr'' value. ''foldM'' looked like
the right fit:

        instrs <- foldM (\is (f, i) -> f i is) [] (zip (cycle [applyE, applyO]) [0,3..size])

Ouch! ''applyE'' and ''applyO'' let me alternate the function I am using to convert values:

            applyE i instrs = do
                is <- toInstrE i
                return (is : instrs)
            applyO i instrs = do
                is <- toInstrO i
                return (is : instrs)

''[0,3..size]'' give me the indices to read process every 3 words in
the buffer. ''cycle [applyE, applyO]'' gives me a list of alternating
functions to apply. I zip those together and fold. My instructions 
pop out the other end!

</div>
</div>
</div>
</div>
</div>
